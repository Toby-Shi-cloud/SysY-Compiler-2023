// matrix power
// https://www.luogu.com.cn/problem/P3390

const int maxn = 10; // max size of matrix
const int mod = 1000 * 1000 * 1000 + 7; // 1e9 + 7
int n;

int matrix[10][10]; // Matrix: n * n
int k[2]; // long long

void getlong(int _long[/*2*/]) {
    _long[1] = getint();
    _long[0] = getint();
}

// memset, different from std's
void _memset(int _ptr[], int _val, int _length) {
    int _i;
    for (_i = 0; _i < _length; _i = _i + 1) {
        _ptr[_i] = _val;
    }
}

// memcpy, different from std's
void _memcpy(int _dst[], int _src[], int _length) {
    int _i = 0;
    for (;_i < _length;) {
        _dst[_i] = _src[_i];
        _i = _i + 1;
    }
}

/*
 * int * int
 * note: as we use signed int, to avert overflow,
 * we assume that the input is less than 2^30.
 * then we can split 30-bit int to '15-bit & 15-bit'
 * return: _ret[0] low 30-bit, _ret[1] high 30-bit
 */
void _mult_int(int x, int y, /* out */ int _ret[/*2*/]) {
    const int _pow15 = 32768; // 2^15
    const int _pow30 = 1073741824; // 2^30
    int x1 = x / _pow15, x0 = x % _pow15;
    int y1 = y / _pow15, y0 = y % _pow15;
    int ans2 = x1 * y1; // _pow30
    int ans1 = x1 * y0 + x0 * y1; // _pow15
    int ans0 = x0 * y0; // _pow0
    _ret[0] = ans0 + (ans1 % _pow15) * _pow15;
    _ret[1] = ans2 + ans1 / _pow15 + _ret[0] / _pow30;
    _ret[0] = _ret[0] % _pow30;
    return /* _ret */;
}


// long % int
int _mod_long(/* in */ int _long[/*2*/], int p) {
    const int _pow15 = 32768; // 2^15
    const int _pow30 = 1073741824; // 2^30
    int _round = _pow30 % p; // high 30-bit * _round % p
    int _temp[2] = { _long[0], _long[1] };
    int _ret = _long[0] % p;
    for (;;) {
        if (!_temp[1]) break;
        _mult_int(_temp[1], _round, _temp);
        _ret = (_ret + _temp[0]) % p;
    }
    return _ret;
}

int _mult_mod(int x, int y, int p) {
    int _mult_ret[2];
    _mult_int(x, y, _mult_ret);
    return _mod_long(_mult_ret, p);
}

// Matrix operator*(const Matrix &x, const Matrix &y)
void matrix_mult(
/* in */ int m1[/*maxn*/][10],
/* in */ int m2[/*maxn*/][10],
/* out */ int _ret[/*maxn*/][10]) {
    _memset(_ret[0], 0, maxn * maxn);
    int i, j, k;
    for(i = 0; i < n; i = i + 1)
        for(j = 0; j < n; j = j + 1)
            for(k = 0; k < n; k = k + 1)
                _ret[i][j] = (_ret[i][j] + _mult_mod(m1[i][k], m2[k][j], mod)) % mod;
    return /* _ret */;
}

void print(int m[][10]) {
    int i, j;
    for(i = 0; i < n; i = i + 1){
        for(j = 0; j < n; j = j + 1)
            if(j) printf(" %d", m[i][j]);
            else printf("%d", m[i][j]);
        printf("\n");
    }
}

// Matrix ^ long
void matrix_pow(
/* in */ int m[/*maxn*/][10],
/* in */ int e[/*2*/],
/* out */ int _ret[/*maxn*/][10]) {
    _memset(_ret[0], 0, maxn * maxn);
    int i;
    for (i = 0; i < n; i = i + 1)
        _ret[i][i] = 1;
    const int _5p29 = 536870912; // 2^30 / 2
    int _base[10][10], _temp[10][10], _exp[2];
    _memcpy(_base[0], m[0], maxn * maxn);
    _memcpy(_exp, e, 2);
    for (;_exp[1] || _exp[0];) {
        if (_exp[0] % 2) {
            _memcpy(_temp[0], _ret[0], maxn * maxn);
            matrix_mult(_temp, _base, _ret);
        }
        _memcpy(_temp[0], _base[0], maxn * maxn);
        matrix_mult(_temp, _temp, _base);
        _exp[0] = _exp[0] / 2 + _exp[1] % 2 * _5p29;
        _exp[1] = _exp[1] / 2;
    }
    return /* _ret */;
}

int main() {
    // printf("21373433\n");
    n = getint();
    getlong(k);
    int i, j;
    for(i = 0; i < n; i = i + 1)
        for(j = 0; j < n; j = j + 1)
            matrix[i][j] = getint();
    int ans[10][10];
    matrix_pow(matrix, k, ans);
    print(ans);
    return 0;
}
